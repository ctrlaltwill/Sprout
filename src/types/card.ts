/**
 * @file src/types/card.ts
 * @summary Core card record types. Defines CardRecordType (the supported card formats:
 * basic, mcq, cloze, cloze-child, io, io-child) and the full CardRecord shape that
 * represents a single flashcard persisted in the store, including fields for every card
 * type, source-location metadata, image-occlusion data, and legacy backward-compat aliases.
 *
 * @exports
 *   - CardRecordType — union type of all supported card format identifiers
 *   - CardRecord — type for a single persistent flashcard record
 *   - normalizeCardOptions — coerces McqOption[] | string[] | null → string[]
 */

/**
 * Safely coerces an MCQ options field to a flat `string[]`.
 *
 * Handles three scenarios:
 *  1. Already `string[]` (normal store data) — returned as-is.
 *  2. `McqOption[]` objects `{ text, isCorrect }` (parser leak / legacy bug) — extracts `.text`.
 *  3. `null` / `undefined` / non-array — returns `[]`.
 *
 * This is the single authoritative boundary between the parser's rich
 * `McqOption` representation and the store's flat `string[]` contract.
 */
export function normalizeCardOptions(raw: unknown): string[] {
  if (!Array.isArray(raw)) return [];
  return raw.map((item: unknown) => {
    if (typeof item === "string") return item;
    if (item && typeof item === "object" && "text" in item && typeof (item as Record<string, unknown>).text === "string") {
      return (item as { text: string }).text;
    }
    if (typeof item === "number" || typeof item === "boolean" || typeof item === "bigint") {
      return String(item);
    }
    return "";
  });
}

/**
 * Returns the set of correct option indices for an MCQ card.
 * Uses `correctIndices` when available, otherwise falls back to `correctIndex`.
 * Always returns a sorted array of unique non-negative integers.
 */
export function getCorrectIndices(card: { correctIndices?: number[] | null; correctIndex?: number | null }): number[] {
  if (Array.isArray(card.correctIndices) && card.correctIndices.length > 0) {
    return [...new Set(card.correctIndices.filter(i => Number.isInteger(i) && i >= 0))].sort((a, b) => a - b);
  }
  if (Number.isFinite(card.correctIndex) && (card.correctIndex as number) >= 0) {
    return [card.correctIndex as number];
  }
  return [];
}

/**
 * Returns true when an MCQ card has multiple correct answers.
 */
export function isMultiAnswerMcq(card: { correctIndices?: number[] | null; correctIndex?: number | null }): boolean {
  return getCorrectIndices(card).length > 1;
}

/** All supported card formats, including child types generated by sync. */
export type CardRecordType = "basic" | "reversed" | "reversed-child" | "mcq" | "cloze" | "cloze-child" | "io" | "io-child" | "oq";

/**
 * Persistent record for a single flashcard.
 *
 * Fields are grouped by card type — only the fields relevant to a given
 * `type` are populated; the rest are `undefined` or `null`.
 */
export type CardRecord = {
  id: string;
  type: CardRecordType;
  title: string | null;

  // ── Basic ──────────────────────────────────────────────────────────────
  q?: string | null;
  a?: string | null;

  // ── Multiple Choice (MCQ) ──────────────────────────────────────────────
  stem?: string | null;
  options?: string[] | null;
  correctIndex?: number | null;
  /** Indices of all correct options (multi-answer MCQ). When present, takes precedence over correctIndex. */
  correctIndices?: number[] | null;

  // ── Ordering Question (OQ) ─────────────────────────────────────────────
  /** Ordered list of steps (correct order). Max 20 items. */
  oqSteps?: string[] | null;

  // ── Cloze ──────────────────────────────────────────────────────────────
  clozeText?: string | null;
  clozeChildren?: number[] | null;
  clozeIndex?: number | null;

  // ── Reversed child ─────────────────────────────────────────────────────
  /** Direction of a reversed-child: "forward" (Q→A) or "back" (A→Q). */
  reversedDirection?: "forward" | "back" | null;

  // ── Image Occlusion (IO) — shared ─────────────────────────────────────
  /** Optional question prompt written inside an IO block. */
  prompt?: string | null;

  // ── IO parent ──────────────────────────────────────────────────────────
  imageRef?: string | null;
  /** @deprecated Alias for `imageRef`; kept for backwards-compat with older stores. */
  ioSrc?: string | null;
  maskMode?: "solo" | "all" | null;

  // ── IO child ───────────────────────────────────────────────────────────
  parentId?: string;
  groupKey?: string;
  rectIds?: string[];
  retired?: boolean;

  // ── Shared metadata ────────────────────────────────────────────────────
  info?: string | null;
  groups?: string[] | null;

  // ── Source location ────────────────────────────────────────────────────
  sourceNotePath: string;
  sourceStartLine: number;

  // ── Legacy / backward-compat aliases ───────────────────────────────────
  /** @deprecated Legacy alias for `sourceNotePath`. */
  location?: string;
  /** @deprecated Legacy alias for `sourceNotePath`. */
  sourcePath?: string;
  /** @deprecated Legacy anchor reference. */
  anchor?: string;
  /** @deprecated Legacy block ID reference. */
  blockId?: string;
  /** @deprecated Legacy alias for `imageRef`. */
  src?: string;
  /** @deprecated Legacy alias for `imageRef`. */
  image?: string;
  /** @deprecated Legacy alias for `groupKey`. */
  ioGroupKey?: string;
  /** @deprecated Legacy alias for `groupKey`. */
  key?: string;
  /** @deprecated Legacy alias for `info`. */
  information?: string | null;
  /** @deprecated Short alias for `info`. */
  i?: string | null;
  /** @deprecated Short alias for `info`. */
  I?: string | null;
  /** @deprecated Legacy nested fields object. */
  fields?: Record<string, unknown>;

  // ── Bookkeeping (written by sync; optional for older stores) ───────────
  createdAt?: number;
  updatedAt?: number;
  lastSeenAt?: number;
};
